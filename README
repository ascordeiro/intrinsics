--------------------------------------------------------------------------------
-
- Aline Santana Cordeiro - ascordeiro@inf.ufpr.br
- LSE - Embedded Sistems Laboratory - 2018
- PPGInf - Federal University of Paran√°
-
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-                               Intrinsics Library                             -
--------------------------------------------------------------------------------
-
-   The Intrinsics-HMC and Intrinsics-MIPS Libraries were developed to simulate
- the ISA's execution of Hybrid Memory Cube (HMC), described in HMC 2.1
- specification (http://www.hybridmemorycube.org), and MIPS. The mainly purpose
- is to write a C or C++ program using these libraries generate a trace that
- simulates the program's execution in one of these architectures. This task
- can be achieved by using the program's binary file as SiNUCA-tracer entry,
- that interprets the libraries instructions and generate the traces in a
- simulation specific format.
-
--------------------------------------------------------------------------------
-
- DATA TYPES -
-
- HMC:
- __h16u1:  16-bit unsigned integer;
- __h64u1:  64-bit unsigned integer;
- __h64u2:  Two 64-bit unsigned integers in a vector;
- __h128u1: 128-bit unsigned integer;
-
- MIPS:
- __m32s1: 32-bit signed integer;
- __m32u1: 32-bit unsigned integer;
- __m64s1: 64-bit signed integer;
- __m64u1: 64-bit unsigned integer;
-
- CHIVE:
- __ch32s: 32-bit signed integer;
- __ch32u: 32-bit unsigned integer;
- __ch64s: 64-bit signed integer;
- __ch64u: 64-bit unsigned integer;
- __ch32f: 32-bit signed float;
-
-   The data types were renamed inspired in Intel Intrinsics function pattern.
- Which identifies the intrinsics data type is the first 2 underlines
- characteres. The third (fouth e fifth for CHIVE) character(s) identify the
- choosen architechture. The next 2 characteres indicates the variable size in
- bits. The next charactere indicates if is a signed or unsigned number. For
- HMC and MIPS, the last one indicates the number of variables assigned to that
- type (As CHIVE is an vectorized instruction, the instruction lenght is
- assigned to instruction name).
-
--------------------------------------------------------------------------------
-
-------------------------------- HMC FUNCTIONS ---------------------------------
-
- The implementation is based on HMC 2.1 specification and does not follows
- exactly the real behave described in the specification.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Dual 8-Byte Signed Add Immediate:
- __h64u2 *_hmc64_saddimm_d(__h64u2 *mem_op, __h64u2 *imm_op)
- Sums two memory operands with two immediate operands (8-byte). The operands
- must have 4-bytes size and must be in two-complement with left zeroes padding
- (4-byte). The result is returned to the call function.
-
- Single 16-Byte Signed Add Immediate:
- __h128u1 _hmc128_saddimm_s(__h128u1 *mem_op, __h128u1 *imm_op)
- Sums a memory operand (16-byte) with an immediate operand in two-complement
- with left zeroes padding (16-byte). The result is returned to the call
- function.
-
- 8-Byte Increment:
- __h64u1 _hmc64_incr_s(__h64u1 *mem_op)
- Increments a memory operand (8-byte) in one unity. The result is returned to
- the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Bit Write:
- __h64u1 _hmc64_bwrite_s(__h64u1 mem_op, __h64u1 imm_op, __h64u1 mask)
- The mask field (8-Byte) selects which immediate operand bits (8-byte) must be
- written in the same positions of memory operand (8-Byte). The result is
- returned to the call function.
-
- 16-Byte Swap:
- __h128u1 _hmc128_bswap_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the immediate operand value into the memory operand address (16-Byte).
- Returns the original memory operand value (16-Byte).
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- BOOLEAN:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 16-Byte AND:
- __h128u1 _hmc128_and_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the AND operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte NAND:
- __h128u1 _hmc128_nand_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the NAND operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte NOR:
- __h128u1 _hmc128_nor_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the NOR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte OR:
- __h128u1 _hmc128_or_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the OR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte)  into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte XOR:
- __h128u1 _hmc128_xor_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the XOR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Compare and Swap if Greater Than:
- __h128u1 _hmc64_cmpswapgt_s(__h64u1 mem_op, __h64u1 imm_op)
- Stores into the memory operand address the greater value between the memory
- operand (8-byte) and immediate operand (8-byte). Returns the original memory
- operand value.
-
- 8-Byte Compare and Swap if Less Than:
- __h128u1 _hmc64_cmpswaplt_s(__h64u1 mem_op, __h64u1 imm_op)
- Stores into the memory operand address the smaller value between the memory
- operand (8-byte) and immediate operand (8-byte). Returns the original memory
- operand value.
-
- 16-Byte Compare and Swap if Greater Than:
- __h128u1 _hmc128_cmpswapgt_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores into the memory operand address the greater value between the memory
- operand (16-byte) and immediate operand (16-byte). Returns the original memory
- operand value.
-
- 16-Byte Compare and Swap if Less Than:
- __h128u1 _hmc128_cmpswaplt_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores into the memory operand address the smaller value between the memory
- operand (16-byte) and immediate operand (16-byte). Returns the original memory
- operand value.
-
- 8-Byte Compare and Swap if Equal:
- __h64u1 _hmc64_cmpswapeq_s(__h64u1 mem_op, __h64u1 imm_op, __h64u1 cmp_field)
- Compares the cmp_field (8-byte) with memory operand value (8-byte). If equal,
- stores the immediate operand value (8-byte) into the memory operand address.
- Returns the original memory operand value.
-
- 16-Byte Compare and Swap if Zero:
- __h128u1 _hmc128_cmpswapz_s(__h128u1 mem_op, __h128u1 imm_op)
- Compares the memory operand value (16-byte) with zero. If equal, stores the
- immediate operand value (16-byte) into the memory operand address. Returns
- the original memory operand value.
-
- 8-Byte Equal To:
- __h16u1 _hmc64_cmpswapgt_s(__h64u1 mem_op, __h64u1 imm_op)
- Verifies is the memory operand value (8-byte) is equal to the immediate
- operand value (8-byte). Returns 1 if equal, 0 if not.
-
- 16-Byte Equal To:
- __h16u1 _hmc128_cmpswapgt_s(__h128u1 mem_op, __h128u1 imm_op)
- Verifies is the memory operand value (16-byte) is equal to the immediate
- operand value (16-byte). Returns 1 if equal, 0 if not.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- CUSTOMIZED:
- These instructions were created to fit better in usual programming problems.
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Compare if Greater Than or equal:
- __h16u1 _hmc64_cmpgteq_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is minor or equal to the immediate
- operand value. If true, returns 0 to the call function, otherwise, returns 1.
-
- 8-Byte Compare if Less Than or equal:
- __h16u1 _hmc64_cmplteq_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is greater or equal to the immediate
- operand value. If true, returns 0 to the call function, otherwise, returns 1.
-
- 8-Byte Compare if Less Than:
- __h16u1 _hmc64_cmplt_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is greater than the immediate operand
- value. If true, returns 0 to the call function, otherwise, returns 1.
-
--------------------------------------------------------------------------------
-
-------------------------------- MIPS FUNCTIONS --------------------------------
-
- The implementation is based on MIPS ISA and does not follows exactly the real
- behave of the architechture. All the instructions were implemented, except
- memory and floating point operations.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Add:
- __m32s1 _mips_add(__m32s1 rs, __m32s1 rt)
- Sums the rs and rt registers and returns the result to the call function.
-
- Add Unsigned:
- __m32u1 _mips_addu(__m32u1 rs, __m32u1 rt)
- Sums the rs and rt registers and returns the result to the call function.
-
- Subtract:
- __m32s1 _mips_sub(__m32s1 rs, __m32s1 rt)
- Subtracts the rs and rt registers and returns the result to the call function.
-
- Subtract Unsigned:
- __m32u1 _mips_subu(__m32u1 rs, __m32u1 rt)
- Subtracts the rs and rt registers and returns the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Add Immediate:
- __m32s1 _mips_addi(__m32s1 rs, __m32s1 imm_op)
- Sums the rs register and immediate operand and returns the result to the call
- function.
-
- Add Immediate Unsigned:
- __m32u1 _mips_addiu(__m32u1 rs, __m32u1 imm_op)
- Sums the rs register and immediate operand and returns the result to the call
- function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- And:
- __m32u1 _mips_and(__m32u1 rs, __m32u1 rt)
- Applies the AND operation between the rs and rt registers and returns the
- result to the call function.
-
- Nor:
- __m32u1 _mips_nor(__m32u1 rs, __m32u1 rt)
- Applies the NOR operation between the rs and rt registers and returns the
- result to the call function.
-
- Or:
- __m32u1 _mips_or(__m32u1 rs, __m32u1 rt)
- Applies the OR operation between the rs and rt registers and returns the
- result to the call function.
-
- Xor:
- __m32u1 _mips_xor(__m32u1 rs, __m32u1 rt)
- Applies the XOR operation between the rs and rt registers and returns the
- result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- And Immediate:
- __m32u1 _mips_andi(__m32u1 rs, __m32u1 imm_op)
- Applies the AND operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- Or Immediate:
- __m32u1 _mips_ori(__m32u1 rs, __m32u1 imm_op)
- Applies the OR operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- Xor Immediate:
- __m32u1 _mips_xori(__m32u1 rs, __m32u1 imm_op)
- Applies the XOR operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Set Less Than:
- __m32s1 _mips_slt(__m32s1 rs, __m32s1 rt)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- Set Less Than Unsigned:
- __m32u1 _mips_sltu(__m32u1 rs, __m32u1 rt)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Set Less Than Immediate:
- __m32s1 _mips_slti(__m32s1 rs, __m32s1 imm_op)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- Set Less Than Immediate Unsigned:
- __m32u1 _mips_sltiu(__m32u1 rs, __m32u1 imm_op)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- SHIFT:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Shift Left Logical:
- __m32u1 _mips_sll(__m32u1 rt, __m32u1 shamt)
- Shifts to the left the shamt value in rt register. Returns the result to the
- call function.
-
- Shift Right Logical:
- __m32u1 _mips_srl(__m32u1 rt, __m32u1 shamt)
- Shifts to the right the shamt value in rt register. Returns the result to the
- call function.
-
- Shift Right Arithmetic:
- __m32s1 _mips_sra(__m32s1 rt, __m32s1 shamt)
- Shifts to the right the shamt value in rt register keeping rt signal. Returns
- the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- MULTIPLICATION/DIVISION:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Divide Only:
- __m32s1 _mips_div(__m32s1 rs, __m32s1 rt)
- Returns to the call function the division between rs and rt registers.
-
- Divide Only Unsigned:
- __m32u1 _mips_divu(__m32u1 rs, __m32u1 rt)
- Returns to the call function the division between rs and rt registers.
-
- Module Only:
- __m32s1 _mips_mod(__m32s1 rs, __m32s1 rt)
- Returns to the call function the module operation between rs and rt registers.
-
- Module Only Unsigned:
- __m32u1 _mips_modu(__m32u1 rs, __m32u1 rt)
- Returns to the call function the module operation between rs and rt registers.
-
- Multiply 32-bits:
- __m32s1 _mips_mult32(__m32s1 rs, __m32s1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 32-bits Unsigned:
- __m32u1 _mips_multu32(__m32u1 rs, __m32u1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 64-bits:
- __m64s1 _mips_mult64(__m32s1 rs, __m32s1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 64-bits Unsigned:
- __m64u1 _mips_multu64(__m32u1 rs, __m32u1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
--------------------------------------------------------------------------------
-
-------------------------------- CHIVE FUNCTIONS -------------------------------
-
- The implementation is based on MIPS and ARM NEON specification and the model
- is inspired in HIVE module for HMC, to vectorize data transfer inside HMC and
- it does not follows exactly the real behave described in these specifications.
- As CHIVE implements vectorized instructions, the vector size is specified
- below.
-
- CH64I: 256-bytes array size to integer types;
- CH2KI: 8-Kbytes arrey size to integer types;
- CH32L: 256-bytes array size to long integer types;
- CH1KL: 8-Kbytes array size to long integer types;
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Add (64 integers):
- _chive64_iadds(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed addition between 32-bit elements source vectors A[0:63] 
- and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Add (2048 integers):
- _chive2K_iadds(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed addition between 32-bit elements source vectors A[0:2047] 
- and B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Add Unsigned (64 integers):
- _chive64_iaddu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned addition between 32-bit elements source vectors A[0:63] 
- and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Add Unsigned (2048 integers):
- _chive2K_iaddu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned addition between 32-bit elements source vectors A[0:2047] 
- and B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Subtract (64 integers):
- _chive64_isubs(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed subtraction between 32-bit elements source vectors A[0:63] 
- and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Subtract (2048 integers):
- _chive2K_isubs(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed subtraction between 32-bit elements source vectors A[0:2047] 
- and B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Subtract Unsigned (64 integers):
- _chive64_isubu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned subtraction between 32-bit elements source vectors A[0:63] 
- and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Subtract Unsigned (2048 integers):
- _chive2K_isubu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned subtraction between 32-bit elements source vectors A[0:2047] 
- and B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Abs (64 integers):
- _chive64_iabss(__ch32s *a, __ch32s *b)
- Takes the absolute value of each 32-bit element in a source vector A[0:63] 
- and stores it into the destination vector B[0:63].
-
- 32-bit Abs (2048 integers):
- _chive2K_iabss(__ch32s *a, __ch32s *b)
- Takes the absolute value of each 32-bit element in a source vector A[0:2047] 
- and stores it into the destination vector B[0:2047].
-
- 32-bit Max (64 integers):
- _chive64_imaxs(__ch32s *a, __ch32s *b, __ch32s *c)
- Find the maximal value between each 32-bit element of source vectors A[0:63] 
- and B[0:63] and stores it into the destination vector C[0:63].
-
- 32-bit Max (2048 integers):
- _chive2K_imaxs(__ch32s *a, __ch32s *b, __ch32s *c)
- Find the maximal value between each 32-bit element of source vectors A[0:2047] 
- and B[0:2047] and stores it into the destination vector C[0:2047].
-
- 32-bit Min (64 integers):
- _chive64_imins(__ch32s *a, __ch32s *b, __ch32s *c)
- Find the minimal value between each 32-bit element of source vectors A[0:63] 
- and B[0:63] and stores it into the destination vector C[0:63].
-
- 32-bit Min (2048 integers):
- _chive2K_imins(__ch32s *a, __ch32s *b, __ch32s *c)
- Find the minimal value between each 32-bit element of source vectors A[0:2047] 
- and B[0:2047] and stores it into the destination vector C[0:2047].
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit And (64 integers):
- _chive64_iandu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform AND operation between 32-bit elements source vectors A[0:63] and 
- B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit And (2048 integers):
- _chive2K_iandu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform AND operation between 32-bit elements source vectors A[0:2047] and 
- B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Or (64 integers):
- _chive64_iorun(__ch32u *a, __ch32u *b, __ch32u *c) 
- Perform OR operation between 32-bit elements source vectors A[0:63] and 
- B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Or (2048 integers):
- _chive2K_iorun(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform OR operation between 32-bit elements of source vectors A[0:2047] and 
- B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Xor (64 integers):
- _chive64_ixoru(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform XOR operation between 32-bit elements source vectors A[0:63] and 
- B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Xor (2048 integers):
- _chive2K_ixoru(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform XOR operation between 32-bit elements source vectors A[0:2047] and 
- B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Not (64 integers):
- _chive64_inots(__ch32s *a, __ch32s *b)
- Perform NOT operation in 32-bit elements source vector A[0:63] and stores 
- the result into the destination vector B[0:63].
-
- 32-bit Not (2048 integers):
- _chive2K_inots(__ch32s *a, __ch32s *b)
- Perform NOT operation in 32-bit elements source vector A[0:2047] and stores 
- the result into the destination vector B[0:2047].
-
- 32-bit Mask (64 integers):
- _chive64_imsks(__ch32s *a, __ch32s *b, __ch32s *c) 
- Insert each signed 32-bit element source vector A[0:63] into the destination 
- vector C[0:63] if the corresponding 32-bit element from source vector B[0:63] 
- is 0, otherwise, it leaves the destination vector unchanged.
-
- 32-bit Mask (2048 integers):
- _chive2K_imsks(__ch32s *a, __ch32s *b, __ch32s *c)
- Insert each signed 32-bit element source vector A[0:2047] into the destination 
- vector C[0:2047] if the corresponding 32-bit element from source vector 
- B[0:2047] is 0, otherwise, it leaves the destination vector unchanged.
-
- 32-bit Masku (64 integers):
- _chive64_imsku(__ch32u *a, __ch32u *b, __ch32u *c)
- Insert each unsigned 32-bit element source vector A[0:63] into the destination 
- vector C[0:63] if the corresponding 32-bit element from source vector B[0:63] 
- is 0, otherwise, it leaves the destination vector unchanged.
-
- 32-bit Masku (2048 integers):
- Insert each unsigned 32-bit element source vector A[0:2047] into the 
- destination vector C[0:2047] if the corresponding 32-bit element from source 
- vector B[0:2047] is 0, otherwise, it leaves the destination vector unchanged.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Set Less Than (64 integers):
- _chive64_islts(__ch32s *a, __ch32s *b, __ch32s *c)
- Compare each signed 32-bit elements from source vectors A[0:63] and B[0:63] 
- and if the element of A[0:63] is minor, then destination source C[0:63] 
- stores 1 in the same position, otherwise, stores 0.
-
- 32-bit Set Less Than (2048 integers):
- _chive2K_islts(__ch32s *a, __ch32s *b, __ch32s *c)
- Compare each signed 32-bit elements from source vectors A[0:2047] and 
- B[0:2047] and if the element of A[0:2047] is minor, then destination source 
- C[0:2047] stores 1 in the same position, otherwise, stores 0.
-
- 32-bit Set Less Than Unsigned (64 integers):
- _chive64_isltu(__ch32u *a, __ch32u *b, __ch32u *c)
- Compare each unsigned 32-bit elements from source vectors A[0:63] and B[0:63] 
- and if the element of A[0:63] is minor, then destination source C[0:63] 
- stores 1 in the same position, otherwise, stores 0.
-
- 32-bit Set Less Than Unsigned (2048 integers):
- _chive2K_isltu(__ch32u *a, __ch32u *b, __ch32u *c)
- Compare each unsigned 32-bit elements from source vectors A[0:2047] and 
- B[0:2047] and if the element of A[0:2047] is minor, then destination source 
- C[0:2047] stores 1 in the same position, otherwise, stores 0.
-
- 32-bit Compare if equal (64 integers):
- _chive64_icmqs(__ch32s *a, __ch32s *b, __ch32s *c)
- Compare each signed 32-bit elements from source vectors A[0:63] and B[0:63] 
- and if they are equal, then destination source C[0:63] stores 1 in the same 
- position, otherwise, stores 0.
-
- 32-bit Compare if equal (2048 integers):
- _chive2K_icmqs(__ch32s *a, __ch32s *b, __ch32s *c)
- Compare each signed 32-bit elements of source vectors A[0:2047] and B[0:2047] 
- and if they are equal, then destination source C[0:2047] stores 1 in the same 
- position, otherwise, stores 0.
-
- 32-bit Compare if equal Unsigned (64 integers):
- _chive64_icmqu(__ch32u *a, __ch32u *b, __ch32u *c)
- Compare each unsigned 32-bit elements of source vectors A[0:63] and B[0:63] 
- and if they are equal, then destination source C[0:63] stores 1 in the same 
- position, otherwise, stores 0.
-
- 32-bit Compare if equal Unsigned (2048 integers):
- _chive2K_icmqu(__ch32u *a, __ch32u *b, __ch32u *c)
- Compares each unsigned 32-bit elements of source vectors A[0:2047] and 
- B[0:2047] and if they are equal, then destination source C[0:2047] stores 1 
- in the same position, otherwise, stores 0.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- SHIFT:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Shift Left Logical (64 integers):
- _chive64_isllu(__ch32u *a, __ch32u *b, __ch32u *c)
- Left shift each 32-bit element in source vector A[0:63] the amount specified 
- in source vector B[0:63] and stores the result into the destination vector 
- C[0:63]. This operation does not shift signal.
-
- 32-bit Shift Left Logical (2048 integers):
- _chive2K_isllu(__ch32u *a, __ch32u *b, __ch32u *c)
- Left shift each 32-bit element in source vector A[0:2047] the amount specified 
- in source vector B[0:2047] and stores the result into the destination vector 
- C[0:2047]. This operation does not shift signal.
-
- 32-bit Shift Right Logical (64 integers):
- _chive64_isrlu(__ch32u *a, __ch32u *b, __ch32u *c)
- Right shift each 32-bit element in source vector A[0:63] the amount specified 
- in source vector B[0:63] and stores the result into the destination vector 
- C[0:63]. This operation does not shift signal.
-
- 32-bit Shift Right Logical (2048 integers):
- _chive2K_isrlu(__ch32u *a, __ch32u *b, __ch32u *c)
- Right shift each 32-bit element in source vector A[0:2047] the amount specified 
- in source vector B[0:2047] and stores the result into the destination vector 
- C[0:2047]. This operation does not shift signal.
-
- 32-bit Shift Right Arithmetic (64 integers):
- _chive64_isras(__ch32s *a, __ch32s *b, __ch32s *c)
- Right shift each 32-bit element in source vector A[0:63] the amount specified 
- in source vector B[0:63] and stores the result into the destination vector 
- C[0:63]. This operation shifts signal.
-
- 32-bit Shift Right Arithmetic (2048 integers):
- _chive2K_isras(__ch32s *a, __ch32s *b, __ch32s *c)
- Right shift each 32-bit element in source vector A[0:2047] the amount specified 
- in source vector B[0:2047] and stores the result into the destination vector 
- C[0:2047]. This operation shifts signal.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- MULTIPLICATION/DIVISION:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Divide Only (64 integers):
- _chive64_idivs(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform a signed division between 32-bit elements from source vectors A[0:63] 
- and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Divide Only (2048 integers):
- _chive2K_idivs(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform a signed division between 32-bit elements from source vectors A[0:2047] 
- and B[0:2047] and stores the result into the destination vector C[0:2047].
-
- 32-bit Divide Only Unsigned (64 integers):
- _chive64_idivu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform an unsigned division between 32-bit elements from source vectors 
- A[0:63] and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Divide Only Unsigned (2048 integers):
- _chive2K_idivu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform an unsigned division between 32-bit elements from source vectors 
- A[0:2047] and B[0:2047] and stores the result into the destination vector 
- C[0:2047].
-
- 32-bit Module Only (64 integers):
- _chive64_imods(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform a signed module operation between 32-bit elements from source vectors 
- A[0:63] and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Module Only (2048 integers):
- _chive2K_imods(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform a signed module operation between 32-bit elements of source vectors 
- A[0:2047] and B[0:2047] and stores the result into the destination vector 
- C[0:2047].
-
- 32-bit Module Only Unsigned (64 integers):
- _chive64_imodu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform an unsigned module operation between 32-bit elements from source 
- vectors A[0:63] and B[0:63] and stores the result into the destination vector 
- C[0:63].
-
- 32-bit Module Only Unsigned (2048 integers):
- _chive2K_imodu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform an unsigned module operation between 32-bit elements from source 
- vectors A[0:2047] and B and stores the result into the destination vector 
- C[0:2047].
-
- 32-bit Multiply (64 integers):
- _chive64_imuls(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed multiplication between 32-bit elements from source vectors 
- A[0:63] and B[0:63] and stores the result into the destination vector 
- C[0:63].
-
- 32-bit Multiply (2048 integers):
- _chive2K_imuls(__ch32s *a, __ch32s *b, __ch32s *c)
- Perform signed multiplication between 32-bit elements from source vectors 
- A[0:2047] and B[0:2047] and stores the result into the destination vector 
- C[0:2047].
-
- 32-bit Multiply Unsigned (64 integers):
- _chive64_imulu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned multiplication between 32-bit elements from source vectors 
- A[0:63] and B[0:63] and stores the result into the destination vector C[0:63].
-
- 32-bit Multiply Unsigned (2048 integers):
- _chive2K_imulu(__ch32u *a, __ch32u *b, __ch32u *c)
- Perform unsigned multiplication between 32-bit elements from source vectors 
- A[0:2047] and B[0:2047] and stores the result into the destination vector 
- C[0:2047].
-
- 64-bit Multiply (32 integers):
- _chive32_imuls(__ch64s *a, __ch64s *b, __ch64s *c)
- Perform signed multiplication between 32-bit elements from source vectors 
- A[0:31] and B[0:31] and stores the result into the destination vector C[0:31].
-
- 64-bit Multiply (1024 integers):
- _chive1K_imuls(__ch64s *a, __ch64s *b, __ch64s *c)
- Perform signed multiplication between 32-bit elements from source vectors 
- A[0:1023] and B[0:1023] and stores the result into the destination vector 
- C[0:1023].
-
- 64-bit Multiply Unsigned (32 integers):
- _chive32_imulu(__ch64u *a, __ch64u *b, __ch64u *c)
- Performs unsigned multiplication between 32-bit elements from source vectors 
- A[0:31] and B[0:31] and stores the result into the destination vector C[0:31].
-
- 64-bit Multiply Unsigned (1024 integers):
- _chive1K_imulu(__ch64u *a, __ch64u *b, __ch64u *c)
- Perform unsigned multiplication between 32-bit elements from source vectors 
- A[0:1023] and B[0:1023] and stores the result into the destination vector 
- C[0:1023].
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Move Immediate Data (64 integers):
- _chive64_imovs(__ch32s *a, __ch32s b)
- Replicate a signed 32-bit immediate b into the vector A[0:63].
-
- 32-bit Move Immediate Data (2048 integers):
- _chive2K_imovs(__ch32s *a, __ch32s b)
- Replicate a signed 32-bit immediate b into the vector A[0:2047].
-
- 32-bit Move Immediate Data Unsigned (64 integers):
- _chive64_imovu(__ch32u *a, __ch32u b)
- Replicate a unsigned 32-bit immediate b into the vector A[0:63].
-
- 32-bit Move Immediate Data (2048 integers):
- _chive2K_imovu(__ch32u *a, __ch32u b)
- Replicate a unsigned 32-bit immediate b into the vector A[0:2047].
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- kNN FLOAT INSTRUCTIONS:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Move Immediate Data (64 floats):
- _chive64_fmovs(__ch32f *a, __ch32f b)
- Replicate a signed 32-bit floating-point immediate b into the vector A[0:63].
-
- 32-bit Subtract (64 floats):
- _chive64_fsubs(__ch32f *a, __ch32f *b, __ch32f *c)
- Perform signed subtraction between 32-bit floating-point elements source 
- vectors A[0:63] and B[0:63] and stores the result into the destination vector 
- C[0:63].
-
- 32-bit Multiply (64 floats):
- _chive64_fmuls(__ch32f *a, __ch32f *b, __ch32f *c)
- Perform signed multiplication between 32-bit floating-point elements from 
- source vectors A[0:63] and B[0:63] and stores the result into the destination 
- vector C[0:63].
-
- 32-bit Cumulative Sum (64 floats):
- _chive64_fcsum(__ch32f *a, __ch32f *b)
- Perform cumulative sum of the 32-bit floating-point elements from source vector 
- A[0:63] in variable b.
-
